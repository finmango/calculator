<div>
    <!-- Import CSV parser -->
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>

    <div id="portfolio-calculator-data">

        <div>
            <h2 v-if="error_message" class="centered" style="text-transform: uppercase;">{{error_message}}</h2>
            <h2 v-else class="centered" style="text-transform: uppercase;">
                The total returns for the simulated period are {{ Formatter.percent(portfolio_returns) }}
            </h2>
        </div>

        <!-- Summary simulation statistics -->
        <table :class="{invisible: error_message !== null}" class="centered" style="display: table; font-size: small">
            <tr>
                <th>Period</th>
                <th>Average</th>
                <th>Max</th>
                <th>Min</th>
            </tr>
            <tr v-show="portfolio_performance['1 Year'].avg">
                <td>1 Year</td>
                <td>{{ Formatter.percent(portfolio_performance['1 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['1 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['1 Year'].min, true) }}</td>
            </tr>
            <tr v-show="portfolio_performance['5 Year'].avg">
                <td>5 Years</td>
                <td>{{ Formatter.percent(portfolio_performance['5 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['5 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['5 Year'].min, true) }}</td>
            </tr>
            <tr v-show="portfolio_performance['10 Year'].avg">
                <td>10 Years</td>
                <td>{{ Formatter.percent(portfolio_performance['10 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['10 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(portfolio_performance['10 Year'].min, true) }}</td>
            </tr>
        </table>

        <!-- Element host for the Google Charts -->
        <div :class="{invisible: error_message !== null}" id="perf-chart-container" class="chart-container"></div>
        <div :class="{invisible: error_message !== null}" id="drawdown-chart-container" class="chart-container"></div>

        <div class="spacer"></div>

        <details>
            <summary>Calculator Options</summary>

            <form class="flex one two-600">

                <script data-include src="rebalance-form.tpl.html"></script>

                <script data-include src="dca-form.tpl.html"></script>

                <script data-include src="div-form.tpl.html"></script>

                <div>
                    <label for="start_date">Simulation Start Date</label>
                    <input type="date" v-model="start_date" min="1975-01-01" @change="update()" />
                </div>

                <div>
                    <label for="start_date">Simulation End Date</label>
                    <input type="date" v-model="end_date" min="1975-01-01" @change="update()" />
                </div>

                <div>
                    <label for="target_allocations">Target Allocations</label>
                    <div id="target_allocations">
                        <div v-for="(value, symbol) in target_allocations">
                            <label for="{{ symbol }}">
                                <small>{{ target_allocations[symbol] }}% {{ symbol }}</small>
                            </label>
                            <input @input="temp()" type="range" v-model.number="target_allocations[symbol]" min="0"
                                max="100" step="5">
                        </div>
                    </div>
                </div>

            </form>
        </details>
    </div>

    <script async>
        function csv2json(url) {
            return new Promise(resolve =>
                Papa.parse(url, { download: true, complete: resolve })
            ).then(res => res.data).then(rows => rows.slice(1).map(row =>
                rows[0].reduce((agg, col, idx) =>
                    Object.assign(agg, { [col]: col === 'Date' ? row[idx] : parseFloat(row[idx]) }), {})
            ));
        }

        // Reference to outer element
        const rootElement = document.currentScript.parentElement;

        // Mount VueJS to the root element
        const app = new Vue({
            el: '#portfolio-calculator-data',
            data: {
                error_message: null,
                target_allocations: {},
                rebalance_schedule: 'yearly',
                schedules: ['Never', 'Yearly', 'Quarterly', 'Monthly', 'Daily'],
                dividend_reinvestment: 'yes',
                dca_schedule: 'never',
                dca_percent: 0,
                start_date: '1995-01-01',
                end_date: new Date().toISOString().slice(0, 10),
                portfolio_returns: 0,
                portfolio_performance: { '1 Year': {}, '5 Year': {}, '10 Year': {} },
                debouncer: null,
                Formatter: Formatter,
            },
            computed: {
            },
            watch: {
            },
            methods: {
                alloc: function () {
                    const alloc = {};
                    for (const [symbol, val] of Object.entries(data.target_allocations)) {
                        if (val > 0) alloc[symbol] = val / 100;
                    }
                    return alloc;
                },
                temp: function () {
                    if (this.debouncer) clearTimeout(this.debouncer);
                    this.debouncer = setTimeout(() => {
                        const tmp = this.target_allocations;
                        this.target_allocations = null;
                        this.target_allocations = tmp;
                    }, 10);
                },
                rebalance: function (C) {
                    const alloc = this.alloc();
                    const total = Object.keys(alloc).reduce((total, symbol) => total + C[symbol], 0);
                    Object.entries(alloc).forEach(([symbol, weight]) => C[symbol] = total * weight);
                },
                meetsSchedule: function (returns, schedule) {
                    const quarter = month => 1 + Math.floor((Number(month) - 1) / 3);
                    const tokenizeDate = date => date.toISOString().slice(0, 10).split('-');
                    if (schedule === 'never' || returns.length < 2)
                        return false;
                    if (schedule === 'yearly')
                        return tokenizeDate(returns.at(-1).Date)[0] !== tokenizeDate(returns.at(-2).Date)[0];
                    if (schedule === 'quarterly')
                        return quarter(tokenizeDate(returns.at(-1).Date)[1]) !== quarter(tokenizeDate(returns.at(-2).Date)[1]);
                    if (schedule === 'monthly')
                        return tokenizeDate(returns.at(-1).Date)[1] !== tokenizeDate(returns.at(-2).Date)[1];
                    if (schedule === 'daily')
                        return true;
                    if (schedule.endsWith('% threshold')) {
                        const threshold = parseInt(schedule.split('%')[0]) / 100;
                        const currentValues = this.alloc.map(symbol => [symbol, returns.at(-1)[symbol]]);
                        const totalAssets = currentValues.reduce((total, [_, val]) => total + val, 0);
                        for (const [symbol, val] of currentValues) {
                            const ratio = val / totalAssets;
                            const target = this.alloc[symbol];
                            const diff = Math.abs(ratio - target) / target;
                            if (Math.abs(ratio - target) / target > threshold) return true;
                        }
                        return false;
                    }
                    throw new Error(`Unknown rebalancing strategy: ${schedule}`);
                },
                update: async function () {

                    const alloc = this.alloc();
                    if (Object.values(alloc).reduce((total, val) => total + val, 0) !== 1) {
                        this.error_message = 'Total allocations must be equal to 100%';
                        return;
                    } else {
                        this.error_message = null;
                    }

                    // Load Google Charts asynchronously on demand
                    await google.charts.load('current', { packages: ['corechart'] });

                    // Wait for the historical data to be fully loaded
                    const symbols = Object.keys(alloc).sort((a, b) => alloc[a] - alloc[b]);
                    const reinvest = this.dividend_reinvestment === 'yes';
                    const history = (await (reinvest ? this.daily_returns_reinvested : this.daily_returns))
                        .filter(row => row.Date.localeCompare(this.start_date) >= 0)
                        .filter(row => row.Date.localeCompare(this.end_date) <= 0)
                        .filter(row => symbols.every(symbol => !isNaN(row[symbol])));

                    const returns = [];
                    const performance = { '1 Year': [], '5 Year': [], '10 Year': [], 'Rebalances': 0 };
                    const C = Object.assign({ Total: 1, Max: 1 }, alloc);
                    for (const x of history) {
                        C.Total = symbols.reduce((total, symbol) => total + C[symbol], 0);
                        C.Max = Math.max(C.Max, C.Total);
                        C.Drawdown = Math.min(0, (C.Total - C.Max) / C.Max);
                        symbols.forEach(symbol => C[symbol] *= (1 + x[symbol]));
                        returns.push(Object.assign({ Date: new Date(x.Date) }, C));

                        // DCA if schedule requests it
                        if (this.meetsSchedule(returns, this.dca_schedule.toLowerCase())) {
                            const alloc = this.alloc();
                            Object.entries(alloc).forEach(([symbol, weight]) =>
                                C[symbol] += this.dca_percent / 100 / symbols.length);
                        }

                        // Rebalance the portfolio if needed
                        if (this.meetsSchedule(returns, this.rebalance_schedule.toLowerCase())) {
                            performance.Rebalances++;
                            this.rebalance(C)
                        }

                        // Keep track of rolling performance
                        [1, 5, 10].forEach(year => {
                            const key = `${year} Year`;
                            const days = year * 365;
                            if (returns.length > days) {
                                const prev = returns.at(-days);
                                const diff = C.Total - prev.Total;
                                const ratio = diff / prev.Total;
                                performance[key].push(ratio);
                            }
                        });
                    }

                    this.portfolio_returns = Math.round((C.Total - 1) * 100) / 100;

                    [1, 5, 10].forEach(year => {
                        const key = `${year} Year`;
                        const sum = performance[key].reduce((total, val) => total + val, 0);
                        const approx = x => Math.round(x * 1000) / 1000;
                        this.portfolio_performance[key].avg = approx(sum / performance[key].length);
                        this.portfolio_performance[key].max = approx(Math.max(...performance[key]));
                        this.portfolio_performance[key].min = approx(Math.min(...performance[key]));
                    })

                    console.log(returns);
                    console.log(performance);
                    const portfolioStr = symbols.map(symbol => `${this.target_allocations[symbol]}% ${symbol}`).join(' · ');

                    const perfTable = new google.visualization.DataTable();
                    perfTable.addColumn({ label: 'Date', type: 'date' });
                    symbols.forEach(symbol => perfTable.addColumn({ label: symbol, type: 'number' }));
                    perfTable.addRows(returns.map(row => ['Date'].concat(symbols).map(symbol => row[symbol])));

                    const drawdownTable = new google.visualization.DataTable();
                    drawdownTable.addColumn({ label: 'Date', type: 'date' });
                    drawdownTable.addColumn({ label: 'Drawdown', type: 'number' });
                    drawdownTable.addRows(returns.map(row => [row['Date'], row['Drawdown']]));

                    const perfElem = rootElement.querySelector('#perf-chart-container');
                    new google.visualization.AreaChart(perfElem).draw(perfTable, Object.assign({}, GOOGLE_CHARTS_CONFIG, {
                        title: `${portfolioStr} Performance`,
                        curveType: 'function',
                        isStacked: true,
                        focusTarget: 'category',
                        colors: null,
                        hAxis: { format: 'MM/yyyy', gridlines: { count: 50 }, ...GOOGLE_CHARTS_CONFIG.hAxis },
                        interpolateNulls: true,
                    }));

                    const drawdownElem = rootElement.querySelector('#drawdown-chart-container');
                    new google.visualization.AreaChart(drawdownElem).draw(drawdownTable, Object.assign({}, GOOGLE_CHARTS_CONFIG, {
                        title: `${portfolioStr} Drawdown`,
                        curveType: 'function',
                        focusTarget: 'category',
                        colors: ['red'],
                        hAxis: { format: 'MM/yyyy', gridlines: { count: 50 }, ...GOOGLE_CHARTS_CONFIG.hAxis },
                        vAxis: { ...GOOGLE_CHARTS_CONFIG.vAxis, viewWindow: { max: 0, min: -1 } },
                        interpolateNulls: true,
                    }));

                    // Hide loading spinners
                    perfElem.style.backgroundImage = 'none';
                }
            }
        });

        // Load data from URL query parameters into the view model
        const data = DataHelper.getQueryData(window.location);
        data.target_allocations = (data.target_allocations || 'SPY:100').split(',').reduce((agg, keyval) => {
            const [key, val] = keyval.split(':', 2);
            return Object.assign(agg, { [key]: parseInt(val) || 0 });
        }, {});
        Object.assign(app, data);

        // Load data from remote JSON file
        const urlBase = 'https://finmango.github.io/portfolio-simulator';
        app.daily_returns = csv2json(`${urlBase}/daily-returns.csv`);
        app.daily_returns_reinvested = csv2json(`${urlBase}/daily-returns-with-dividends-reinvested.csv`);

        app.daily_returns.then(rows => Object.keys(rows[0]).filter(symbol => symbol !== 'Date').forEach(symbol =>
            data.target_allocations[symbol] = data.target_allocations[symbol] || 0));

        // Ask VueJS to reload anytime any of the data changes
        Object.keys(data).forEach(key => app.$watch(key, function () { this.update() }, { deep: true }));

        // Make sure load is triggered even if we didn't pass any data
        app.update();
    </script>
</div>