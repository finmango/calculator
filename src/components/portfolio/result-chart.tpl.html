<div>
    <!-- Import CSV parser -->
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>

    <div id="portfolio-calculator-data">

        <div>
            <h2 v-if="error_message" class="centered" style="text-transform: uppercase;">{{error_message}}</h2>
            <div v-else>
                <h2 class="centered" style="text-transform: uppercase;">
                    The total returns for the simulated period are
                    {{ Formatter.percent(performance.returns, true) }}
                </h2>
                <p style="text-align: justify;">
                    With your investment of <b class="green">{{ Formatter.price(initial_investment) }}</b> from
                    <b>{{ performance.start_date?.toLocaleDateString() }}</b> until
                    <b>{{ performance.end_date?.toLocaleDateString() }}</b> you would have made an additional
                    <b :class="[performance.returns > 0 ? 'green' : 'red']">
                        {{ Formatter.price(initial_investment * (performance.returns - performance.dca_total)) }}</b>,
                    after excluding contributions via dollar-cost averaging. The maximum
                    drawdown in the simulated strategy was
                    <b class="red">{{ Formatter.percent(performance.max_drawdown, true) }}</b>. The
                    portfolio was rebalanced <b>{{ performance.rebalance_count }}</b> time(s) and
                    <b>{{ performance.dca_count }}</b> additional contribution(s) totaling
                    <b class="green">{{ Formatter.price(dca_amount * performance.dca_count) }}</b>
                    were made as part of the selected dollar-cost averaging strategy.
                </p>
            </div>
        </div>

        <!-- Summary simulation statistics -->
        <table :class="{invisible: error_message !== null}" class="centered" style="display: table; font-size: small">
            <tr>
                <th>Period</th>
                <th>Annualized</th>
                <th>Average</th>
                <th>Max</th>
                <th>Min</th>
            </tr>
            <tr v-show="performance['1 Year'].avg">
                <td>1 Year</td>
                <td>{{ Formatter.percent(performance['1 Year'].annualized, true) }}</td>
                <td>{{ Formatter.percent(performance['1 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(performance['1 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(performance['1 Year'].min, true) }}</td>
            </tr>
            <tr v-show="performance['5 Year'].avg">
                <td>5 Years</td>
                <td>{{ Formatter.percent(performance['5 Year'].annualized, true) }}</td>
                <td>{{ Formatter.percent(performance['5 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(performance['5 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(performance['5 Year'].min, true) }}</td>
            </tr>
            <tr v-show="performance['10 Year'].avg">
                <td>10 Years</td>
                <td>{{ Formatter.percent(performance['10 Year'].annualized, true) }}</td>
                <td>{{ Formatter.percent(performance['10 Year'].avg, true) }}</td>
                <td>{{ Formatter.percent(performance['10 Year'].max, true) }}</td>
                <td>{{ Formatter.percent(performance['10 Year'].min, true) }}</td>
            </tr>
        </table>

        <div class="flex one two-600">

            <div class="fourth" style="padding-top: 24px">
                <label for="target_allocations">Target Allocations</label>
                <div id="target_allocations">
                    <div v-for="(value, symbol) in target_allocations">
                        <label for="{{ symbol }}">
                            <small>{{ target_allocations[symbol] }}% {{ symbol }}</small>
                        </label>
                        <input @input="temp()" type="range" v-model.number="target_allocations[symbol]" min="0"
                            max="100" step="5" style="margin-top: -10px; padding: 0;">
                    </div>
                </div>
            </div>

            <div class="three-fourth">
                <!-- Element host for the Google Charts -->
                <div :class="{invisible: error_message !== null}" id="perf-chart-container" class="chart-container">
                </div>
                <div :class="{invisible: error_message !== null}" id="drawdown-chart-container" class="chart-container">
                </div>
            </div>

        </div>

        <div class="spacer"></div>

        <details>
            <summary style="display: list-item">Adjust Calculator Options</summary>

            <form class="flex one two-600">

                <script data-include src="rebalance-form.tpl.html"></script>

                <script data-include src="dca-form.tpl.html"></script>

                <script data-include src="div-form.tpl.html"></script>

                <script data-include src="init-form.tpl.html"></script>

                <script data-include src="form-dates.tpl.html"></script>

            </form>
        </details>

        <div class="spacer"></div>
    </div>

    <script async>
        function csv2json(url) {
            return new Promise(resolve =>
                Papa.parse(url, { download: true, complete: resolve })
            ).then(res => res.data).then(rows => rows.slice(1).map(row =>
                rows[0].reduce((agg, col, idx) =>
                    Object.assign(agg, { [col]: col === 'Date' ? row[idx] : parseFloat(row[idx]) }), {})
            ));
        }

        // Reference to outer element
        const rootElement = document.currentScript.parentElement;

        // Mount VueJS to the root element
        const app = new Vue({
            el: '#portfolio-calculator-data',
            data: {
                error_message: null,
                target_allocations: {},
                initial_investment: 1,
                rebalance_schedule: 'yearly',
                schedules: ['Never', 'Yearly', 'Quarterly', 'Monthly', 'Daily'],
                dividend_reinvestment: 'yes',
                dca_schedule: 'never',
                dca_amount: 0,
                start_date: '1995-01-01',
                end_date: new Date().toISOString().slice(0, 10),
                portfolio_returns: 0,
                performance: { '1 Year': {}, '5 Year': {}, '10 Year': {} },
                debouncer1: null,
                debouncer2: null,
                Formatter: Formatter,
            },
            computed: {
                dca_ratio: function () { return this.dca_amount / this.initial_investment }
            },
            watch: {
            },
            methods: {
                alloc: function () {
                    const alloc = {};
                    for (const [symbol, val] of Object.entries(data.target_allocations)) {
                        if (val > 0) alloc[symbol] = val / 100;
                    }
                    return alloc;
                },
                temp: function () {
                    if (this.debouncer1) clearTimeout(this.debouncer1);
                    this.debouncer1 = setTimeout(() => {
                        const tmp = this.target_allocations;
                        this.target_allocations = null;
                        this.target_allocations = tmp;
                    }, 10);
                },
                meetsSchedule: function (returns, schedule) {
                    const quarter = month => 1 + Math.floor((Number(month) - 1) / 3);
                    const tokenizeDate = date => date.toISOString().slice(0, 10).split('-');
                    if (schedule === 'never' || returns.length < 2)
                        return false;
                    if (schedule === 'yearly')
                        return tokenizeDate(returns.at(-1).Date)[0] !== tokenizeDate(returns.at(-2).Date)[0];
                    if (schedule === 'quarterly')
                        return quarter(tokenizeDate(returns.at(-1).Date)[1]) !== quarter(tokenizeDate(returns.at(-2).Date)[1]);
                    if (schedule === 'monthly')
                        return tokenizeDate(returns.at(-1).Date)[1] !== tokenizeDate(returns.at(-2).Date)[1];
                    if (schedule === 'daily')
                        return true;
                    if (schedule.endsWith('% threshold')) {
                        const threshold = parseInt(schedule.split('%')[0]) / 100;
                        const currentValues = this.alloc.map(symbol => [symbol, returns.at(-1)[symbol]]);
                        const totalAssets = currentValues.reduce((total, [_, val]) => total + val, 0);
                        for (const [symbol, val] of currentValues) {
                            const ratio = val / totalAssets;
                            const target = this.alloc[symbol];
                            const diff = Math.abs(ratio - target) / target;
                            if (Math.abs(ratio - target) / target > threshold) return true;
                        }
                        return false;
                    }
                    throw new Error(`Unknown rebalancing strategy: ${schedule}`);
                },
                update: async function (debounce = true) {
                    if (this.debouncer2) clearTimeout(this.debouncer2);
                    if (debounce) {
                        this.debouncer2 = setTimeout(() => { this.update(false) }, 500);
                        return;
                    }

                    // Clear error message
                    this.error_message = null;

                    // Early exit: allocations do not amount to 100%
                    const alloc = this.alloc();
                    if (Object.values(alloc).reduce((total, val) => total + val, 0) !== 1) {
                        this.error_message = 'Total allocations must be equal to 100%';
                        return;
                    }

                    // Load Google Charts asynchronously on demand
                    await google.charts.load('current', { packages: ['corechart'] });

                    // Wait for the historical data to be fully loaded
                    const symbols = Object.keys(alloc).sort((a, b) => alloc[a] - alloc[b]);
                    const reinvest = this.dividend_reinvestment === 'yes';
                    const history = (await (reinvest ? this.daily_returns_reinvested : this.daily_returns))
                        .filter(row => row.Date.localeCompare(this.start_date) >= 0)
                        .filter(row => row.Date.localeCompare(this.end_date) <= 0)
                        .filter(row => symbols.every(symbol => !isNaN(row[symbol])));

                    // Early exit: no history found for the given parameters
                    if (!history || history.length === 0) {
                        this.error_message = 'No data found for the selected parameters. Try selecting a different date.';
                        return;
                    }

                    const returns = [];
                    const rolling = [1, 5, 10].reduce((agg, n) => ({ [n]: { returns: [], drawdowns: [] }, ...agg }), {});
                    const performance = { '1 Year': [], '5 Year': [], '10 Year': [], 'Rebalances': 0, 'DCA': 0 };
                    const C = Object.assign({ Total: 1, Max: 1 }, alloc);
                    for (const x of history) {
                        C.Total = symbols.reduce((total, symbol) => total + C[symbol], 0);
                        C.Max = Math.max(C.Max, C.Total);
                        C.Drawdown = Math.min(0, (C.Total - C.Max) / C.Max);
                        symbols.forEach(symbol => C[symbol] *= (1 + x[symbol]));
                        returns.push(Object.assign({ Date: new Date(x.Date) }, C));

                        // DCA if schedule requests it
                        if (this.meetsSchedule(returns, this.dca_schedule.toLowerCase())) {
                            performance.DCA++;
                            Object.entries(alloc).forEach(([symbol, weight]) =>
                                C[symbol] += this.dca_ratio / symbols.length);
                        }

                        // Rebalance the portfolio if needed
                        if (this.meetsSchedule(returns, this.rebalance_schedule.toLowerCase())) {
                            performance.Rebalances++;
                            const total = symbols.reduce((total, symbol) => total + C[symbol], 0);
                            Object.entries(alloc).forEach(([symbol, weight]) => C[symbol] = total * weight);
                        }

                        // Keep track of rolling performance
                        Object.keys(rolling).forEach(year => {
                            const days = year * 365;
                            if (returns.length > days) {
                                const prev = returns.at(-days);
                                const diff = C.Total - prev.Total;
                                const ratio = diff / prev.Total;
                                rolling[year].returns.push(ratio);
                                // rolling[year].drawdowns.push(Math.min(...returns.slice(-days).map(row => row.Drawdown)));
                            }
                        });
                    }

                    this.portfolio_returns = Math.round((C.Total - 1) * 100) / 100;
                    this.performance['returns'] = Math.round((C.Total - 1) * 100) / 100;
                    this.performance['dca_count'] = performance['DCA'];
                    this.performance['rebalance_count'] = performance['Rebalances'];
                    this.performance['dca_total'] = performance['DCA'] * this.dca_ratio;
                    this.performance['start_date'] = returns[0]['Date'];
                    this.performance['end_date'] = returns.at(-1)['Date'];
                    this.performance['max_drawdown'] = Math.min(...returns.map(row => row['Drawdown']));

                    Object.keys(rolling).forEach(year => {
                        const approx = x => Math.round(x * 1000) / 1000;
                        const sum = rolling[year].returns.reduce((total, val) => total + val, 0);

                        const key = `${year} Year`;
                        this.performance[key] = {};
                        this.performance[key].avg = approx(sum / rolling[year].returns.length);
                        this.performance[key].max = approx(Math.max(...rolling[year].returns));
                        this.performance[key].min = approx(Math.min(...rolling[year].returns));
                        this.performance[key].annualized = approx(sum / rolling[year].returns.length / year);
                    });

                    this.performance = { ...this.performance };
                    console.log(JSON.stringify(this.performance));

                    console.log(returns);
                    const portfolioStr = symbols.map(symbol => `${this.target_allocations[symbol]}% ${symbol}`).join(' · ');

                    const perfTable = new google.visualization.DataTable();
                    perfTable.addColumn({ label: 'Date', type: 'date' });
                    symbols.forEach(symbol => perfTable.addColumn({ label: symbol, type: 'number' }));
                    perfTable.addRows(returns.map(row => ['Date'].concat(symbols).map(symbol => row[symbol])));

                    const drawdownTable = new google.visualization.DataTable();
                    drawdownTable.addColumn({ label: 'Date', type: 'date' });
                    drawdownTable.addColumn({ label: 'Drawdown', type: 'number' });
                    drawdownTable.addRows(returns.map(row => [row['Date'], row['Drawdown']]));

                    const perfElem = rootElement.querySelector('#perf-chart-container');
                    new google.visualization.AreaChart(perfElem).draw(perfTable, Object.assign({}, GOOGLE_CHARTS_CONFIG, {
                        title: `${portfolioStr} Performance`,
                        curveType: 'function',
                        isStacked: true,
                        focusTarget: 'category',
                        colors: null,
                        hAxis: { ...GOOGLE_CHARTS_CONFIG.hAxis, format: 'MM/yyyy', gridlines: { count: 50 } },
                        vAxis: { ...GOOGLE_CHARTS_CONFIG.vAxis, textPosition: 'in' },
                        interpolateNulls: true,
                        chartArea: { ...GOOGLE_CHARTS_CONFIG.chartArea, left: 0 },

                    }));

                    const drawdownElem = rootElement.querySelector('#drawdown-chart-container');
                    new google.visualization.AreaChart(drawdownElem).draw(drawdownTable, Object.assign({}, GOOGLE_CHARTS_CONFIG, {
                        title: `${portfolioStr} Drawdown`,
                        curveType: 'function',
                        focusTarget: 'category',
                        colors: ['red'],
                        hAxis: { ...GOOGLE_CHARTS_CONFIG.hAxis, format: 'MM/yyyy', gridlines: { count: 50 } },
                        vAxis: { ...GOOGLE_CHARTS_CONFIG.vAxis, textPosition: 'in', viewWindow: { max: 0, min: -1 } },
                        interpolateNulls: true,
                        chartArea: { ...GOOGLE_CHARTS_CONFIG.chartArea, left: 0 },
                    }));

                    // Hide loading spinners
                    perfElem.style.backgroundImage = 'none';
                }
            }
        });

        // Load data from URL query parameters into the view model
        const data = DataHelper.getQueryData(window.location);
        data.target_allocations = (data.target_allocations || 'SPY:100').split(',').reduce((agg, keyval) => {
            const [key, val] = keyval.split(':', 2);
            return Object.assign(agg, { [key]: parseInt(val) || 0 });
        }, {});
        Object.assign(app, data);

        // Load data from remote JSON file
        const urlBase = 'https://finmango.github.io/portfolio-simulator';
        app.daily_returns = csv2json(`${urlBase}/daily-returns.csv`);
        app.daily_returns_reinvested = csv2json(`${urlBase}/daily-returns-with-dividends-reinvested.csv`);

        app.daily_returns.then(rows => Object.keys(rows[0]).filter(symbol => symbol !== 'Date').forEach(symbol =>
            data.target_allocations[symbol] = data.target_allocations[symbol] || 0));

        // Ask VueJS to reload anytime any of the data changes
        Object.keys(data).forEach(key => app.$watch(key, function () { this.update() }, { deep: true }));

        // Make sure load is triggered even if we didn't pass any data
        app.update();
    </script>
</div>